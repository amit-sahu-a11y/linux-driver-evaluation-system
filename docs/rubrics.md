#  Evaluation Rubrics for Linux Device Driver Coding Models

This document explains how the evaluation system measures the quality of Linux device driver code generated by coding models. The evaluation is split into **quantitative**, **qualitative**, and **safety/security**-based metrics with defined weights.

---

## + 1. Correctness (40%)

**Goal**: Does the driver compile and function as intended?

| Metric                | Description                                                  | Max Score |
|----------------------|--------------------------------------------------------------|-----------|
| Compilation Success  | Does the code compile without errors?                        | 15%       |
| Warning-Free Build   | Are there minimal or no compiler warnings?                   | 5%        |
| Basic Functionality  | Does the driver implement required operations (e.g. read/write)? | 10%   |
| Kernel Integration   | Uses kernel APIs, macros, and conventions correctly?          | 10%       |

---

##  2. Security & Safety (25%)

**Goal**: Is the driver secure, safe, and free from common vulnerabilities?

| Metric               | Description                                                   | Max Score |
|---------------------|---------------------------------------------------------------|-----------|
| Buffer Safety        | Bounds checking, avoids overflows/underflows                 | 10%       |
| Race Conditions      | Proper use of mutexes/spinlocks to handle concurrency        | 5%        |
| Input Validation     | Validates user and hardware inputs to avoid crashes          | 5%        |
| Resource Management  | Proper allocation and deallocation (no leaks)                | 5%        |

---

##  3. Code Quality (20%)

**Goal**: Is the code maintainable, readable, and idiomatic?

| Metric              | Description                                                   | Max Score |
|--------------------|---------------------------------------------------------------|-----------|
| Style Compliance    | Follows Linux kernel coding style (`coding-style.rst`)        | 5%        |
| Documentation       | Meaningful comments and kerneldoc for public functions        | 5%        |
| Maintainability     | Code modularity, function naming, clean logic                 | 5%        |
| Error Handling      | Detects and gracefully handles runtime errors                 | 5%        |

---

##  4. Performance (10%)

**Goal**: Is the driver efficient and resource-aware?

| Metric              | Description                                                  | Max Score |
|--------------------|--------------------------------------------------------------|-----------|
| System Resource Use | Avoids unnecessary CPU/memory usage                         | 5%        |
| Scalability         | Behavior under concurrent/multiple access                   | 5%        |

---

##  5. Advanced Features (5%) â€” *Bonus*

**Optional but adds extra points if implemented**

| Metric              | Description                                                  | Max Bonus |
|--------------------|--------------------------------------------------------------|-----------|
| Power Management    | Supports suspend/resume events                              | 2%        |
| Device Tree Support | Parses device tree bindings (for platform drivers)          | 2%        |
| Debugging Features  | Integrated logging, tracing, or debugfs entries             | 1%        |

---

##  Example Scoring Breakdown
{
"compilation": {
"success_rate": 1.0,
"warnings_count": 1,
"errors_count": 0
},
"functionality": {
"basic_operations": 0.9,
"error_handling": 0.8,
"edge_cases": 0.6
},
"security": {
"buffer_safety": 0.95,
"race_conditions": 0.85,
"input_validation": 0.7
},
"code_quality": {
"style_compliance": 0.85,
"documentation": 0.65,
"maintainability": 0.75
},
"overall_score": 83.0
}
